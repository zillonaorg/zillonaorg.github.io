{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Zillona Org Documentation Project Advanced Technology at Human Scale What is Zillona Org? Zillona Org is a global collective of professionals and enthusiasts that come together to advance important technology projects. As an organization we leverage the best of modern tools and processes to collaborate effectively and transparently on projects big and small. Please visit our official website at zillona.org and our GitHub organization at github.com/zillonaorg Projects Our roster of active projects changes frequently. Please see our currently featured projects as well as our core ongoing projects in the navigation bar of this site to get started.","title":"[Zillona Org](https://www.zillona.org) Documentation Project"},{"location":"#zillona-org-documentation-project","text":"Advanced Technology at Human Scale","title":"Zillona Org Documentation Project"},{"location":"#what-is-zillona-org","text":"Zillona Org is a global collective of professionals and enthusiasts that come together to advance important technology projects. As an organization we leverage the best of modern tools and processes to collaborate effectively and transparently on projects big and small. Please visit our official website at zillona.org and our GitHub organization at github.com/zillonaorg","title":"What is Zillona Org?"},{"location":"#projects","text":"Our roster of active projects changes frequently. Please see our currently featured projects as well as our core ongoing projects in the navigation bar of this site to get started.","title":"Projects"},{"location":"contributing/","text":"Contributing","title":"Contributing"},{"location":"docker_exercise-1/","text":"Docker Lifecycle Exercise Explore published docker images at https:///hub.docker.com, pull and modify upstream Dockerfiles, build, run and push local images to a private repository. Explore the differences between instructions, images and containers. Visit https://hub.docker.com/_/nginx in your browser for official Nginx docker images Select mainline to view latest release of Dockerfile in main branch Pull upstream Git repository and navigate to mainline Dockerfile git clone https://github.com/nginxinc/docker-nginx.git cd docker-nginx/mainline/debian/ Open and examin Dockerfile vim Dockerfile Copy upstream docker image from Dockerfile FROM debian:bookworm-slim Familiarize yourself with Dockerfile best practices Make a new branch of this repository git checkout -b $YOUR_NAME In a new directory create a fresh Dockerfile using base image from upstream Dockerfile. mkdir docker cd ./docker echo 'FROM debian:bookworm-slim' > Dockerfile Build docker image from new Dockerfile docker build -t debian:local . Create docker container from local image and enter container. docker run -it debian:local bash Install nginx and dependencies apt update && apt upgrade -y apt install -y nginx Start Nginx service nginx Test Nginx from your workstation curl localhost Exit container exit relaunch container docker run -it debian:local bash Start Nginx service nginx Add commands to re-install nginx to Dockerfile RUN apt update && apt upgrade -y RUN apt install -y nginx Add CMD line to bottom of Dockerfile to run nginx in container CMD [\"nginx\"] Build docker image from your new Dockerfile docker build -t nginx:local . relaunch container docker run -d nginx:local Test local container from your workstation curl localhost Push Dockerfile to git repository git add docker/Dockerfile git commit -m \"Add Dockerfile\" git push Save container to new image docker tag nginx:local registry.gitlab.com/zillona-dojo/nginx:$YOUR_NAME Authenticate to prvate registry docker login registry.gitlab.com Push container to private registry docker push registry.gitlab.com/zillona-dojo/nginx:$YOUR_NAME Clone website repository and run container from image registry mounting local web content git clone https://gitlab.com/zillona-dojo/website.git docker run -dv ${PWD}:/usr/share/nginx/html registry.gitlab.com/zillona-dojo/nginx:$YOUR_NAME","title":"Docker Lifecycle Exercise"},{"location":"docker_exercise-1/#docker-lifecycle-exercise","text":"Explore published docker images at https:///hub.docker.com, pull and modify upstream Dockerfiles, build, run and push local images to a private repository. Explore the differences between instructions, images and containers. Visit https://hub.docker.com/_/nginx in your browser for official Nginx docker images Select mainline to view latest release of Dockerfile in main branch Pull upstream Git repository and navigate to mainline Dockerfile git clone https://github.com/nginxinc/docker-nginx.git cd docker-nginx/mainline/debian/ Open and examin Dockerfile vim Dockerfile Copy upstream docker image from Dockerfile FROM debian:bookworm-slim Familiarize yourself with Dockerfile best practices Make a new branch of this repository git checkout -b $YOUR_NAME In a new directory create a fresh Dockerfile using base image from upstream Dockerfile. mkdir docker cd ./docker echo 'FROM debian:bookworm-slim' > Dockerfile Build docker image from new Dockerfile docker build -t debian:local . Create docker container from local image and enter container. docker run -it debian:local bash Install nginx and dependencies apt update && apt upgrade -y apt install -y nginx Start Nginx service nginx Test Nginx from your workstation curl localhost Exit container exit relaunch container docker run -it debian:local bash Start Nginx service nginx Add commands to re-install nginx to Dockerfile RUN apt update && apt upgrade -y RUN apt install -y nginx Add CMD line to bottom of Dockerfile to run nginx in container CMD [\"nginx\"] Build docker image from your new Dockerfile docker build -t nginx:local . relaunch container docker run -d nginx:local Test local container from your workstation curl localhost Push Dockerfile to git repository git add docker/Dockerfile git commit -m \"Add Dockerfile\" git push Save container to new image docker tag nginx:local registry.gitlab.com/zillona-dojo/nginx:$YOUR_NAME Authenticate to prvate registry docker login registry.gitlab.com Push container to private registry docker push registry.gitlab.com/zillona-dojo/nginx:$YOUR_NAME Clone website repository and run container from image registry mounting local web content git clone https://gitlab.com/zillona-dojo/website.git docker run -dv ${PWD}:/usr/share/nginx/html registry.gitlab.com/zillona-dojo/nginx:$YOUR_NAME","title":"Docker Lifecycle Exercise"},{"location":"dojo/","text":"Welcome to the Zillona Dojo Doing the do. Doing it well. What is Zillona Dojo? The \"Dojo\" is the public facing, open source community of Zillona Org. Here dojo members and associates work together to learn new skills, refine existing skills and master the core skills needed to collaborate effectively on modern technology projects and at the highest levels of the tech industry. Getting Involved To be initiated into the Zillona Dojo reach out to a member in good standing and ask them to be your membership sponsor. That existing member can introduce you to the other members and arrange for your access to our tools and resources. Slack: zillona.slack.com/channels/dojo Jira: zillona.atlassian.net/jira/core/projects/DOJ/board Git project: github.com/orgs/zillonaorg/projects/dojo Website: dojo.zillona.org Skill progression in the Dojo Things to Know & Things to Learn Please see our skill tree for skill progression information and links. Membership Types Dojo members have multiple tracks for involvement and advancement Dojo membership Internship Apprenticeship Zillona Org membership Association Dojo Member: Dojo membership is a blanket term for contributors of all skill levels and advancement tracks. Prospective members must demonstrate basic ability with prerequisite skills in order to qualify for membership. Once a member is accepted they should begin working on completion of the initial skills checklist to prepare their development environment and qualify for advancement. Once competency has been demonstrated by completion of the initial skills checklist a member may work towards completion of other tracks. Intern: Internships are granted to promissing dojo members who wish to focus on learning and refining new skills. To qualify for an internship a member must establish completion of the initial skills checklist as well as submit a resume outlining their current competence with the technologies outlined in the skill tree and have the endorsement of another member active in apprenticeship or above. Successfull completion of the internship track involves demonstrating competence in the core skills outlined in the skill tree as well as a track record with at least one other skill from the intermediate skills section of the skill tree. Successful completion of an internship requires an exit interview where skills are validated after which the internship can be added to your resume and your status of having successful completed the internship will be validated by Zillona Org as needed. Aprentice: Apprenticeship is for members who wish to qualify for Zillona Org membership or seek employment in the industry. Apprentices work to refine and expand their skills working on projects under the guidance of Zillona Org members and will complete an industry certification in the course of their apprenticeship. Apprenticeship is open to anyone who has successfully completed an internship or anyone who has completed the initial skills checklist as well as having demonstrated proficiency with core skills outlined in the skill tree and at least one skill from the intermediate skills section of the skill tree. Successful candidates will also have a demonstrated track record of mentorship among the interns and other members. To apply for an apprenticeship a member must submit an updated resume outlining their current competence with the technologies outlined in the skill tree and complete a pannel interview with members active in Zillona Org. Successful completion of an apprenticeship program requires completion of an industry certification exam involving one of the skills in the intermediate skills section of the skill tree. Apprenticeship concludes with an exit interview where core and intermediate skills are validated after which the apprenticeship can be added to your resume and an endorsement from Zillona Org will be provided as well as validation of your status of having successful completed the apprenticeship. Zillona Org Member: Zillona Org members have a direct affiliation with Zillona Org. As such they have broader and deeper access to Zillona Org resources and decision making. Zillona Org members provide oversite for the Dojo and other Zillona projects and have voting rights within the organization. Not all Dojo members will become Zillona Org members and not all Zillona Org members participate in the Dojo. Associate: Association status is used for contributors from the industry collaborating in a limited scope such as giving seminars or providing other professional services but not otherwise affiliated with Zillona Org. Associates also include contributors with non-technical backgrounds such as SEO, marketing, and social media management, as well as other complimentary talents. Associate roles are available to leaders in the broader community with proven skills and a track record of willingness to share and mentor.","title":"Dojo"},{"location":"dojo/#welcome-to-the-zillona-dojo","text":"Doing the do. Doing it well.","title":"Welcome to the Zillona Dojo"},{"location":"dojo/#what-is-zillona-dojo","text":"The \"Dojo\" is the public facing, open source community of Zillona Org. Here dojo members and associates work together to learn new skills, refine existing skills and master the core skills needed to collaborate effectively on modern technology projects and at the highest levels of the tech industry.","title":"What is Zillona Dojo?"},{"location":"dojo/#getting-involved","text":"To be initiated into the Zillona Dojo reach out to a member in good standing and ask them to be your membership sponsor. That existing member can introduce you to the other members and arrange for your access to our tools and resources. Slack: zillona.slack.com/channels/dojo Jira: zillona.atlassian.net/jira/core/projects/DOJ/board Git project: github.com/orgs/zillonaorg/projects/dojo Website: dojo.zillona.org","title":"Getting Involved"},{"location":"dojo/#skill-progression-in-the-dojo","text":"Things to Know & Things to Learn Please see our skill tree for skill progression information and links.","title":"Skill progression in the Dojo"},{"location":"dojo/#membership-types","text":"Dojo members have multiple tracks for involvement and advancement Dojo membership Internship Apprenticeship Zillona Org membership Association Dojo Member: Dojo membership is a blanket term for contributors of all skill levels and advancement tracks. Prospective members must demonstrate basic ability with prerequisite skills in order to qualify for membership. Once a member is accepted they should begin working on completion of the initial skills checklist to prepare their development environment and qualify for advancement. Once competency has been demonstrated by completion of the initial skills checklist a member may work towards completion of other tracks. Intern: Internships are granted to promissing dojo members who wish to focus on learning and refining new skills. To qualify for an internship a member must establish completion of the initial skills checklist as well as submit a resume outlining their current competence with the technologies outlined in the skill tree and have the endorsement of another member active in apprenticeship or above. Successfull completion of the internship track involves demonstrating competence in the core skills outlined in the skill tree as well as a track record with at least one other skill from the intermediate skills section of the skill tree. Successful completion of an internship requires an exit interview where skills are validated after which the internship can be added to your resume and your status of having successful completed the internship will be validated by Zillona Org as needed. Aprentice: Apprenticeship is for members who wish to qualify for Zillona Org membership or seek employment in the industry. Apprentices work to refine and expand their skills working on projects under the guidance of Zillona Org members and will complete an industry certification in the course of their apprenticeship. Apprenticeship is open to anyone who has successfully completed an internship or anyone who has completed the initial skills checklist as well as having demonstrated proficiency with core skills outlined in the skill tree and at least one skill from the intermediate skills section of the skill tree. Successful candidates will also have a demonstrated track record of mentorship among the interns and other members. To apply for an apprenticeship a member must submit an updated resume outlining their current competence with the technologies outlined in the skill tree and complete a pannel interview with members active in Zillona Org. Successful completion of an apprenticeship program requires completion of an industry certification exam involving one of the skills in the intermediate skills section of the skill tree. Apprenticeship concludes with an exit interview where core and intermediate skills are validated after which the apprenticeship can be added to your resume and an endorsement from Zillona Org will be provided as well as validation of your status of having successful completed the apprenticeship. Zillona Org Member: Zillona Org members have a direct affiliation with Zillona Org. As such they have broader and deeper access to Zillona Org resources and decision making. Zillona Org members provide oversite for the Dojo and other Zillona projects and have voting rights within the organization. Not all Dojo members will become Zillona Org members and not all Zillona Org members participate in the Dojo. Associate: Association status is used for contributors from the industry collaborating in a limited scope such as giving seminars or providing other professional services but not otherwise affiliated with Zillona Org. Associates also include contributors with non-technical backgrounds such as SEO, marketing, and social media management, as well as other complimentary talents. Associate roles are available to leaders in the broader community with proven skills and a track record of willingness to share and mentor.","title":"Membership Types"},{"location":"featured/","text":"Featured Projects Featured Projects Zillona Dojo","title":"Featured"},{"location":"featured/#featured-projects","text":"Featured Projects","title":"Featured Projects"},{"location":"featured/#zillona-dojo","text":"","title":"Zillona Dojo"},{"location":"git_exercise-1/","text":"Beginners Git Lifecycle Exercise Get hands on with Git This exercise will guide you through basic Git commands for version control. Task Clone a Repository: Find a repository on GitHub you'd like to work with. Copy its HTTPS URL. In your terminal, navigate to where you want to store the project and run: git clone <repository_url> Create a New Branch: It's good practice to create a new branch for your work. Navigate into the cloned repository: cd <repository_name> . Then create a branch: git checkout -b <new_branch_name> . (If theres an existing branch, you can switch to it using: git checkout <existing_branch_name> .) Make Changes: Open the project files in your code editor and make some modifications. Save your changes. Stage Changes: Tell Git to track your changes: git add <file_name> (for specific files) or git add . (to stage all changes). Commit Changes: Record your changes with a descriptive message: git commit -m \"Your commit message here\" Push Changes: Send your committed changes to the remote repository (GitHub): git push origin <new_branch_name> Skills Practiced This exercise introduces you to: Cloning a repository ( git clone ) Creating a new branch ( git checkout -b ) Staging changes ( git add ) Committing changes ( git commit -m ) Pushing changes to a remote repository ( git push ) By practicing these commands, you'll start building a foundation for version control and collaboration using Git.","title":"Beginners Git Lifecycle Exercise"},{"location":"git_exercise-1/#beginners-git-lifecycle-exercise","text":"","title":"Beginners Git Lifecycle Exercise"},{"location":"git_exercise-1/#get-hands-on-with-git","text":"This exercise will guide you through basic Git commands for version control.","title":"Get hands on with Git"},{"location":"git_exercise-1/#task","text":"Clone a Repository: Find a repository on GitHub you'd like to work with. Copy its HTTPS URL. In your terminal, navigate to where you want to store the project and run: git clone <repository_url> Create a New Branch: It's good practice to create a new branch for your work. Navigate into the cloned repository: cd <repository_name> . Then create a branch: git checkout -b <new_branch_name> . (If theres an existing branch, you can switch to it using: git checkout <existing_branch_name> .) Make Changes: Open the project files in your code editor and make some modifications. Save your changes. Stage Changes: Tell Git to track your changes: git add <file_name> (for specific files) or git add . (to stage all changes). Commit Changes: Record your changes with a descriptive message: git commit -m \"Your commit message here\" Push Changes: Send your committed changes to the remote repository (GitHub): git push origin <new_branch_name>","title":"Task"},{"location":"git_exercise-1/#skills-practiced","text":"This exercise introduces you to: Cloning a repository ( git clone ) Creating a new branch ( git checkout -b ) Staging changes ( git add ) Committing changes ( git commit -m ) Pushing changes to a remote repository ( git push ) By practicing these commands, you'll start building a foundation for version control and collaboration using Git.","title":"Skills Practiced"},{"location":"git_exercise-2/","text":"Advanced Git Exercise Configure git locally Set gits \"core\" editor to your editor of choice. I have chosen Vim below. git config --global core.editor \"vim\" If you are using Vim you can add the below lines to your .vimrc file to enforce the commit conventions discussed in a later section. \" Force the cursor onto a new line after 80 characters set textwidth=80 \" However, in Git commit messages, let\u2019s make it 72 characters autocmd FileType gitcommit set textwidth=72 \" Colour the 81st (or 73rd) column so that we don\u2019t type over our limit set colorcolumn=+1 \" In Git commit messages, also colour the 51st column (for titles) autocmd FileType gitcommit set colorcolumn+=51 Branching strategy We use a parallel 'develop' branch for staging changes and annotated tags for semantic versioning git tag -a v1.0.1 <commit> Follow the commit message conventions outlined below to annotate your tags. Commit Messages An excellent source of insight into what commit messages are for and why commit conventions matter. https://cbea.ms/git-commit/ We follow a simplified commit convention based off the popular Angular commit convention https://www.conventionalcommits.org/en/v1.0.0/ From the root of this repository run the following command to configure this projects commit template. git config --global commit.template ${PWD}/.git-commit-template Here is a lengthy example of a properly formatted commit message feat(docs): Add 50 char subject in imperative mood More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of the commit and the rest of the text as the body. The blank line separating the summary from the body is critical (unless you omit the body entirely); various tools like `log`, `shortlog` and `rebase` can get confused if you run the two together. Explain the problem that this commit is solving. Focus on why you are making this change as opposed to how (the code explains that). Are there side effects or other unintuitive consequences of this change? Here's the place to explain them. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary here If you use an issue tracker, put references to them at the bottom, like this: Resolves: #123 See also: #456, #789 Configure commitlint locally or as a commit hook. https://github.com/semantic-release/semantic-release","title":"Advanced Git Exercise"},{"location":"git_exercise-2/#advanced-git-exercise","text":"","title":"Advanced Git Exercise"},{"location":"git_exercise-2/#configure-git-locally","text":"Set gits \"core\" editor to your editor of choice. I have chosen Vim below. git config --global core.editor \"vim\"","title":"Configure git locally"},{"location":"git_exercise-2/#if-you-are-using-vim-you-can-add-the-below-lines-to-your-vimrc-file-to","text":"enforce the commit conventions discussed in a later section. \" Force the cursor onto a new line after 80 characters set textwidth=80 \" However, in Git commit messages, let\u2019s make it 72 characters autocmd FileType gitcommit set textwidth=72 \" Colour the 81st (or 73rd) column so that we don\u2019t type over our limit set colorcolumn=+1 \" In Git commit messages, also colour the 51st column (for titles) autocmd FileType gitcommit set colorcolumn+=51","title":"If you are using Vim you can add the below lines to your .vimrc file to"},{"location":"git_exercise-2/#branching-strategy","text":"We use a parallel 'develop' branch for staging changes and annotated tags for semantic versioning git tag -a v1.0.1 <commit> Follow the commit message conventions outlined below to annotate your tags.","title":"Branching strategy"},{"location":"git_exercise-2/#commit-messages","text":"An excellent source of insight into what commit messages are for and why commit conventions matter. https://cbea.ms/git-commit/ We follow a simplified commit convention based off the popular Angular commit convention https://www.conventionalcommits.org/en/v1.0.0/ From the root of this repository run the following command to configure this projects commit template. git config --global commit.template ${PWD}/.git-commit-template Here is a lengthy example of a properly formatted commit message feat(docs): Add 50 char subject in imperative mood More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of the commit and the rest of the text as the body. The blank line separating the summary from the body is critical (unless you omit the body entirely); various tools like `log`, `shortlog` and `rebase` can get confused if you run the two together. Explain the problem that this commit is solving. Focus on why you are making this change as opposed to how (the code explains that). Are there side effects or other unintuitive consequences of this change? Here's the place to explain them. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary here If you use an issue tracker, put references to them at the bottom, like this: Resolves: #123 See also: #456, #789 Configure commitlint locally or as a commit hook. https://github.com/semantic-release/semantic-release","title":"Commit Messages"},{"location":"initial_skills/","text":"Initial Skills Install Debian VM Install tools mkdocs git docker vim Pull code from Github Install Nginx Install Docker Engine Markdown Help Thanks to makeareadme.com for this template and cheat sheet . \\ Please reference the official GitHub Markdown style guide when editing.","title":"Initial Skills"},{"location":"initial_skills/#initial-skills","text":"","title":"Initial Skills"},{"location":"initial_skills/#install-debian-vm","text":"","title":"Install Debian VM"},{"location":"initial_skills/#install-tools","text":"mkdocs git docker vim","title":"Install tools"},{"location":"initial_skills/#pull-code-from-github","text":"","title":"Pull code from Github"},{"location":"initial_skills/#install-nginx","text":"","title":"Install Nginx"},{"location":"initial_skills/#install-docker-engine","text":"","title":"Install Docker Engine"},{"location":"initial_skills/#markdown-help","text":"Thanks to makeareadme.com for this template and cheat sheet . \\ Please reference the official GitHub Markdown style guide when editing.","title":"Markdown Help"},{"location":"java_troubleshooting/","text":"Comprehensive Guide to Observability in Java Applications In the world of Java application development and operations, understanding how a Java application is configured and operates is paramount for maintaining system health and performance. Observability in this aspect refers to the ability to measure and understand the internal state of an application through its external outputs, such as metrics, profiler captures and logs. For Java applications, effective observability involves a broad range of topics, including memory management, thread behavior, performance metrics, error tracking, and system resource usage. This guide attempts to provides a comprehensive overview of these topics to help you monitor and analyze Java applications effectively. Memory Management and Garbage Collection Heap Memory Storage for Objects: The heap is where Java allocates memory for objects created during program execution. This includes both temporary objects and long-lived data. Dynamic Memory Allocation: Java applications rely on the heap for dynamic memory allocation, meaning objects are created and managed at runtime. Heap Size Configuration: Parameters such as -Xms (initial heap size at runtime) and -Xmx (maximum memory usage size for the heap). Garbage Collection (GC) GC Metrics: Monitoring metrics such as GC pause times, execution times, frequency of GC events, and heap usage before and after GC. Currently, frequency, heap usage and execution times are availble in DataDog. Memory Leaks Detection Tools: Developers usually use tools like jProfiler to identify memory leaks and analyze heap dumps. What Happens with Threads When GC Fails Minor GC Failures Minor GC Overview Frequency: It occurs more frequently than Major GC as it focuses on short-lived objects. Thread Impact During Minor GC Failures Increased Pause Times: If minor GC fails to reclaim enough memory due to high allocation rates or fragmentation, the JVM (Java Virtual Machine) may experience longer pause times. Threads are paused during this process, leading to delays in handling requests and tasks which can cause requests and tasks to fail assuming they\u2019re async/timeout based. Thread Interruption: Threads that are executing tasks requiring memory may be blocked or delayed while GC is in progress. This can lead to increased response times and reduced throughput. Major GC Failures Major GC Overview Scope: Major GC (also known as Full GC) deals with the Old Generation (Tenured space) and the entire heap. It is more comprehensive and involves cleaning up both Young and Old Generations. Frequency: It is less frequent but more resource-intensive compared to Minor GC. Thread Impact During Major GC Failures Extended Pause Times: If major GC fails to reclaim sufficient memory, it may result in extended pause times, where all application threads are stopped. This can severely impact the application's responsiveness and overall performance where it\u2019s possible that the application could crash. Thread Contention: Long GC pauses can cause threads to wait for extended periods, leading to thread contention and potential bottlenecks. Threads that are waiting for memory to become available might cause delays in processing tasks or handling incoming requests. Application Freezes: Prolonged GC pauses may lead to application freezes or unresponsiveness, especially if the JVM cannot allocate the required memory despite continuous GC efforts. General Effects of GC Failures Increased CPU Usage: Frequent and prolonged GC cycles can lead to high CPU usage as the JVM spends more time performing garbage collection rather than executing application code. OutOfMemoryError: If GC fails to free up sufficient memory and the heap is exhausted, the JVM may throw an OutOfMemoryError resulting in a crash visible in the application logs. This error is indicative of impending application crashes and/or significant instability Thread Management and Concurrency Thread States and Lifecycle Thread States: Understand the various thread states (e.g., RUNNABLE, WAITING, BLOCKED, TIMED_WAITING). Thread Pools Configuration: Monitor thread pool settings, such as core pool size, maximum pool size, and queue capacity. Metrics: Track metrics like active threads, queue length, and task completion rates. Concurrency Issues Deadlocks: Deadlocks occur when threads are waiting indefinitely for resources held by each other. Starvation and Livelocks: Threads are either perpetually waiting or continuously changing states without making progress. Thread Management and Concurrency Failure definitions and symptoms Thread Management and Concurrency Failure Deadlocks Definition: A deadlock occurs when two or more threads are each waiting for the other to release a resource, creating a cycle of dependencies that prevents any of them from proceeding. Symptoms: Threads become stuck and do not make any progress, leading to system stalls or unresponsiveness. Starvation Definition: Starvation happens when a thread is perpetually denied the resources it needs to proceed because other threads are continually being given priority. Symptoms: The affected thread is left unable to execute, causing delays or failures in task completion. Livelocks Definition: A livelock occurs when threads keep changing states in response to each other but never make actual progress. Unlike deadlock, threads are active but still unable to complete their tasks. Symptoms: Threads keep running and interacting but fail to make progress, leading to inefficiency and potential performance issues. Race Conditions Definition: A race condition happens when multiple threads access shared data concurrently, and the final outcome depends on the unpredictable order of access. Symptoms: Erratic behavior or incorrect results due to unsynchronized access to shared resources. Thread Contention Definition: Thread contention arises when multiple threads compete for the same resources, leading to delays and reduced performance. Symptoms: Increased context switching, longer execution times, and reduced overall throughput. Resource Leaks Definition: Resource leaks occur when threads fail to release resources (like locks, file handles, or memory) properly, causing resources to be held longer than necessary. Symptoms: Resource exhaustion/overconsumption, leading to degraded performance or system crashes. Application Performance Metrics Response Time Latency: Measures latency for various types of requests (e.g., HTTP requests, database queries). Throughput and Tolerance Request Rate: Tracks the number of requests processed by the appliation in a given unit of time (usually millisecond). Load Testing: Conduct load testing to understand application behavior under stress and high traffic. Error Rates and types Exception Tracking: Monitor the frequency and types of exceptions occurring in the application. Types: Null Pointer Exception (NPE) - Cause: Attempting to use an object reference that has not been initialized (i.e.,it is null ). IllegalArgumentException - Cause: Passing an illegal or inappropriate argument to a method. IOException - Cause: Errors related to input and output operations, such as file reading/writing issues. Note: There are many many more but these are the few I have notes/documentation/experience with. System Resource Utilization CPU Usage Profiling: Developers use profiling tools like jProfiler to measure CPU usage and identify hotspots. Resource Contention: This is where multiple threads or processes compete for resources. Disk I/O I/O Metrics: Track read and write operations, disk usage, and file system performance. Database I/O: Monitor database interaction patterns and optimize queries to reduce impact on I/O load. Network Traffic Traffic Analysis: Measures inbound and outbound network traffic and latency. Network Latency: Monitor for network latency and bandwidth usage, especially for applications with significant network communication. Logging Log Levels: Developers set different logging levels (verbosity from highest lowest: e.g., TRACE, DEBUG, INFO, WARN, ERROR) to capture the right amount of information depending on the importance of the actions being taken without filling up log storage needlessly. This helps in troubleshooting and pinpointing issues related to the application's functionality. Application Resilience Fault Tolerance Retries and Timeouts: A developer will configure retries and timeouts for failures and ensure they are handled gracefully. Typically these retries and timeouts are printed in the application logs.","title":"Comprehensive Guide to Observability in Java Applications"},{"location":"java_troubleshooting/#comprehensive-guide-to-observability-in-java-applications","text":"In the world of Java application development and operations, understanding how a Java application is configured and operates is paramount for maintaining system health and performance. Observability in this aspect refers to the ability to measure and understand the internal state of an application through its external outputs, such as metrics, profiler captures and logs. For Java applications, effective observability involves a broad range of topics, including memory management, thread behavior, performance metrics, error tracking, and system resource usage. This guide attempts to provides a comprehensive overview of these topics to help you monitor and analyze Java applications effectively.","title":"Comprehensive Guide to Observability in Java Applications"},{"location":"java_troubleshooting/#memory-management-and-garbage-collection","text":"Heap Memory Storage for Objects: The heap is where Java allocates memory for objects created during program execution. This includes both temporary objects and long-lived data. Dynamic Memory Allocation: Java applications rely on the heap for dynamic memory allocation, meaning objects are created and managed at runtime. Heap Size Configuration: Parameters such as -Xms (initial heap size at runtime) and -Xmx (maximum memory usage size for the heap). Garbage Collection (GC) GC Metrics: Monitoring metrics such as GC pause times, execution times, frequency of GC events, and heap usage before and after GC. Currently, frequency, heap usage and execution times are availble in DataDog. Memory Leaks Detection Tools: Developers usually use tools like jProfiler to identify memory leaks and analyze heap dumps. What Happens with Threads When GC Fails","title":"Memory Management and Garbage Collection"},{"location":"java_troubleshooting/#minor-gc-failures","text":"Minor GC Overview Frequency: It occurs more frequently than Major GC as it focuses on short-lived objects. Thread Impact During Minor GC Failures Increased Pause Times: If minor GC fails to reclaim enough memory due to high allocation rates or fragmentation, the JVM (Java Virtual Machine) may experience longer pause times. Threads are paused during this process, leading to delays in handling requests and tasks which can cause requests and tasks to fail assuming they\u2019re async/timeout based. Thread Interruption: Threads that are executing tasks requiring memory may be blocked or delayed while GC is in progress. This can lead to increased response times and reduced throughput.","title":"Minor GC Failures"},{"location":"java_troubleshooting/#major-gc-failures","text":"Major GC Overview Scope: Major GC (also known as Full GC) deals with the Old Generation (Tenured space) and the entire heap. It is more comprehensive and involves cleaning up both Young and Old Generations. Frequency: It is less frequent but more resource-intensive compared to Minor GC. Thread Impact During Major GC Failures Extended Pause Times: If major GC fails to reclaim sufficient memory, it may result in extended pause times, where all application threads are stopped. This can severely impact the application's responsiveness and overall performance where it\u2019s possible that the application could crash. Thread Contention: Long GC pauses can cause threads to wait for extended periods, leading to thread contention and potential bottlenecks. Threads that are waiting for memory to become available might cause delays in processing tasks or handling incoming requests. Application Freezes: Prolonged GC pauses may lead to application freezes or unresponsiveness, especially if the JVM cannot allocate the required memory despite continuous GC efforts. General Effects of GC Failures Increased CPU Usage: Frequent and prolonged GC cycles can lead to high CPU usage as the JVM spends more time performing garbage collection rather than executing application code. OutOfMemoryError: If GC fails to free up sufficient memory and the heap is exhausted, the JVM may throw an OutOfMemoryError resulting in a crash visible in the application logs. This error is indicative of impending application crashes and/or significant instability","title":"Major GC Failures"},{"location":"java_troubleshooting/#thread-management-and-concurrency","text":"Thread States and Lifecycle Thread States: Understand the various thread states (e.g., RUNNABLE, WAITING, BLOCKED, TIMED_WAITING). Thread Pools Configuration: Monitor thread pool settings, such as core pool size, maximum pool size, and queue capacity. Metrics: Track metrics like active threads, queue length, and task completion rates. Concurrency Issues Deadlocks: Deadlocks occur when threads are waiting indefinitely for resources held by each other. Starvation and Livelocks: Threads are either perpetually waiting or continuously changing states without making progress. Thread Management and Concurrency Failure definitions and symptoms","title":"Thread Management and Concurrency"},{"location":"java_troubleshooting/#thread-management-and-concurrency-failure","text":"Deadlocks Definition: A deadlock occurs when two or more threads are each waiting for the other to release a resource, creating a cycle of dependencies that prevents any of them from proceeding. Symptoms: Threads become stuck and do not make any progress, leading to system stalls or unresponsiveness. Starvation Definition: Starvation happens when a thread is perpetually denied the resources it needs to proceed because other threads are continually being given priority. Symptoms: The affected thread is left unable to execute, causing delays or failures in task completion. Livelocks Definition: A livelock occurs when threads keep changing states in response to each other but never make actual progress. Unlike deadlock, threads are active but still unable to complete their tasks. Symptoms: Threads keep running and interacting but fail to make progress, leading to inefficiency and potential performance issues. Race Conditions Definition: A race condition happens when multiple threads access shared data concurrently, and the final outcome depends on the unpredictable order of access. Symptoms: Erratic behavior or incorrect results due to unsynchronized access to shared resources. Thread Contention Definition: Thread contention arises when multiple threads compete for the same resources, leading to delays and reduced performance. Symptoms: Increased context switching, longer execution times, and reduced overall throughput. Resource Leaks Definition: Resource leaks occur when threads fail to release resources (like locks, file handles, or memory) properly, causing resources to be held longer than necessary. Symptoms: Resource exhaustion/overconsumption, leading to degraded performance or system crashes.","title":"Thread Management and Concurrency Failure"},{"location":"java_troubleshooting/#application-performance-metrics","text":"Response Time Latency: Measures latency for various types of requests (e.g., HTTP requests, database queries). Throughput and Tolerance Request Rate: Tracks the number of requests processed by the appliation in a given unit of time (usually millisecond). Load Testing: Conduct load testing to understand application behavior under stress and high traffic. Error Rates and types Exception Tracking: Monitor the frequency and types of exceptions occurring in the application. Types: Null Pointer Exception (NPE) - Cause: Attempting to use an object reference that has not been initialized (i.e.,it is null ). IllegalArgumentException - Cause: Passing an illegal or inappropriate argument to a method. IOException - Cause: Errors related to input and output operations, such as file reading/writing issues. Note: There are many many more but these are the few I have notes/documentation/experience with.","title":"Application Performance Metrics"},{"location":"java_troubleshooting/#system-resource-utilization","text":"CPU Usage Profiling: Developers use profiling tools like jProfiler to measure CPU usage and identify hotspots. Resource Contention: This is where multiple threads or processes compete for resources. Disk I/O I/O Metrics: Track read and write operations, disk usage, and file system performance. Database I/O: Monitor database interaction patterns and optimize queries to reduce impact on I/O load. Network Traffic Traffic Analysis: Measures inbound and outbound network traffic and latency. Network Latency: Monitor for network latency and bandwidth usage, especially for applications with significant network communication. Logging Log Levels: Developers set different logging levels (verbosity from highest lowest: e.g., TRACE, DEBUG, INFO, WARN, ERROR) to capture the right amount of information depending on the importance of the actions being taken without filling up log storage needlessly. This helps in troubleshooting and pinpointing issues related to the application's functionality.","title":"System Resource Utilization"},{"location":"java_troubleshooting/#application-resilience","text":"Fault Tolerance Retries and Timeouts: A developer will configure retries and timeouts for failures and ensure they are handled gracefully. Typically these retries and timeouts are printed in the application logs.","title":"Application Resilience"},{"location":"linux_exercise-1/","text":"Linux Exercise Get hands on with the terminal This document outlines a series of basic Linux commands you'll practice. Task Navigate to the Home Directory: Begin by navigating to your user's home directory using the cd ~ command. This tilde symbol ( ~ ) represents a shortcut to your home directory. Verify Current Location: Use the pwd command to display the absolute path of your current working directory. This helps confirm you're in your home directory. List Directory Contents: Use the ls command to list the contents of the current directory, which should be your home directory at this point. Create a New Directory: Create a new directory named \"documents\" using the mkdir documents command. Change Directory: Navigate into the newly created \"documents\" directory using the cd documents command. Verify Current Location (Again): Use the pwd command again to display the absolute path of your current working directory. This time, it should show the path to the \"documents\" directory. Create a Text File: Create a new text file named \"test.txt\" within the \"documents\" directory using the touch test.txt command. Verify File Existence: Use the ls command again to confirm the presence of the \"test.txt\" file in the current directory. View File Contents (Optional): Use the cat test.txt command to display the contents of the \"test.txt\" file on the screen. However, cat doesn't work well with large files, so be cautious. There is no content in this file, therefore there is no output. You will learn how to edit the content of files in a later exercise. Copy a File: Let's take the \"test.txt\" file we've created and copy it to our home directory. Use the cp test.txt ~ command to copy the \"test.txt\" file to your home directory. Move a File (or Rename): Use the mv test.txt another_name.txt command to rename the \"test.txt\" file within the \"documents\" directory to \"another_name.txt\". Alternatively, you can use mv to move the file to another directory. For example, mv another_name.txt ~ would move it back to your home directory. Navigate Back to Home Directory: Return to your home directory using the cd .. command. The double dots ( .. ) represent the parent directory of the current location. Delete test.txt and any other files: Delete the \"test.txt\" file and any other files you've created within the home directory using the rm test.txt command. Use ls again to confirm the deletion. Be cautious when using rm , as deleted files are typically unrecoverable. Delete the Directory: Finally, delete the \"documents\" directory using the rmdir documents command. Remember that rmdir only works on empty directories; remove any files within \"documents\" first if necessary. Skills Practiced This exercise tests your understanding of: Basic navigation commands (cd) Displaying current working directory (pwd) Listing directory contents (ls) Creating directories (mkdir) Creating files (touch) Deleting files (rm) Deleting directories (rmdir) Viewing file contents (cat, optional) Copying files (cp) Moving/Renaming files (mv) By successfully completing these tasks, you'll gain a solid foundation for working with directories and files in the Linux terminal.","title":"Linux Exercise"},{"location":"linux_exercise-1/#linux-exercise","text":"","title":"Linux Exercise"},{"location":"linux_exercise-1/#get-hands-on-with-the-terminal","text":"This document outlines a series of basic Linux commands you'll practice.","title":"Get hands on with the terminal"},{"location":"linux_exercise-1/#task","text":"Navigate to the Home Directory: Begin by navigating to your user's home directory using the cd ~ command. This tilde symbol ( ~ ) represents a shortcut to your home directory. Verify Current Location: Use the pwd command to display the absolute path of your current working directory. This helps confirm you're in your home directory. List Directory Contents: Use the ls command to list the contents of the current directory, which should be your home directory at this point. Create a New Directory: Create a new directory named \"documents\" using the mkdir documents command. Change Directory: Navigate into the newly created \"documents\" directory using the cd documents command. Verify Current Location (Again): Use the pwd command again to display the absolute path of your current working directory. This time, it should show the path to the \"documents\" directory. Create a Text File: Create a new text file named \"test.txt\" within the \"documents\" directory using the touch test.txt command. Verify File Existence: Use the ls command again to confirm the presence of the \"test.txt\" file in the current directory. View File Contents (Optional): Use the cat test.txt command to display the contents of the \"test.txt\" file on the screen. However, cat doesn't work well with large files, so be cautious. There is no content in this file, therefore there is no output. You will learn how to edit the content of files in a later exercise. Copy a File: Let's take the \"test.txt\" file we've created and copy it to our home directory. Use the cp test.txt ~ command to copy the \"test.txt\" file to your home directory. Move a File (or Rename): Use the mv test.txt another_name.txt command to rename the \"test.txt\" file within the \"documents\" directory to \"another_name.txt\". Alternatively, you can use mv to move the file to another directory. For example, mv another_name.txt ~ would move it back to your home directory. Navigate Back to Home Directory: Return to your home directory using the cd .. command. The double dots ( .. ) represent the parent directory of the current location. Delete test.txt and any other files: Delete the \"test.txt\" file and any other files you've created within the home directory using the rm test.txt command. Use ls again to confirm the deletion. Be cautious when using rm , as deleted files are typically unrecoverable. Delete the Directory: Finally, delete the \"documents\" directory using the rmdir documents command. Remember that rmdir only works on empty directories; remove any files within \"documents\" first if necessary.","title":"Task"},{"location":"linux_exercise-1/#skills-practiced","text":"This exercise tests your understanding of: Basic navigation commands (cd) Displaying current working directory (pwd) Listing directory contents (ls) Creating directories (mkdir) Creating files (touch) Deleting files (rm) Deleting directories (rmdir) Viewing file contents (cat, optional) Copying files (cp) Moving/Renaming files (mv) By successfully completing these tasks, you'll gain a solid foundation for working with directories and files in the Linux terminal.","title":"Skills Practiced"},{"location":"linux_exercise-2/","text":"Linux Exercise TODO: Create presentation and exercise","title":"Linux Exercise"},{"location":"linux_exercise-2/#linux-exercise","text":"TODO: Create presentation and exercise","title":"Linux Exercise"},{"location":"orchestration/","text":"Zillona Container Orchestration Our flagship project that other projects rely upon for infrastructure. Slack: zillona.slack.com/channels/zillona Jira: zillona.atlassian.net/jira/core/projects/ZIL/board Git project: github.com/orgs/zillonaorg/projects/zillona Website: zillona.org Technology Stack Kubernetes nginx ingress Calico Terraform Ansible","title":"Container Orchestration"},{"location":"orchestration/#zillona-container-orchestration","text":"Our flagship project that other projects rely upon for infrastructure. Slack: zillona.slack.com/channels/zillona Jira: zillona.atlassian.net/jira/core/projects/ZIL/board Git project: github.com/orgs/zillonaorg/projects/zillona Website: zillona.org","title":"Zillona Container Orchestration"},{"location":"orchestration/#technology-stack","text":"Kubernetes nginx ingress Calico Terraform Ansible","title":"Technology Stack"},{"location":"skill_tree/","text":"Skill Tree Progression Follow the DevOps roadmap at roadmap.sh/devops to get a high-level idea of our skills roadmap. For details of our internal path see the skill tree below. Notes for Contributors to this document Link useful resources for each skill below Regularly vet 3rd party tutorials and prefer official tutorials where prudent Create exercises linking to existing documentation for complex tasks Try to order links as follows Official upstream project documentation Style guide if applicable Certification link if applicable Official registry or repository if applicable Official tutorials and examples 3rd party tutorials and examples Internal exercises and presentations Prerequisite Skills Things to know before you get involved. Navigate Linux filesystem Ubuntu tutorial Dojo Linux exercise #1 Edit local files Ubuntu tutorial Dojo Vim exercise #1 Basic Git usage Official beginers guide GitHub command examples Dojo git exercise #1 Initial skills Set up your development environment and gain confidence with the tools and skills outlined in this section to get started and become involved with Zillona Dojo projects. Install a Debian VM on your development workstation. Install cli tools and dependency packages (vim, git, curl, etc) Bash scripting (Save install steps) Create branch from \"develop\" branch of this repo and edit documentation Markdown Add, commit, and push changes to your new branch Validate changes to repository and create merge request to develop branch Install nginx in the VM Configure nginx from the CLI Install Docker on the VM Pull nginx Docker container for local validation Core Skills These are the most important and fundamental skills to develop as a newly initiated member of the Dojo. Linux Building on basic Linux skills Debian GNU/Linux documentation Git Building on basic git skills Official documentation Gitlab best practices guide Atlassian tutorials & guides Interactive branching tutorial Commit message guide Dojo git exercise #2 Docker Develop core Docker skills Official Documentation Dockerfile best practices Docker Hub Dojo Docker exercise #1 Intermediate Skills Here the skill tree begins to branch out and become more dense and specialized. Refer to the DevOps roadmap to get your bearings. Amazon Web Services (AWS) Official documentation AWS certification Google Cloud Platform (GCP) Official documentation Google Cloud certificates Official tutorials Microsoft Azure Cloud Official documentation Azure certification Bash (Bourne Again SHell) Official GNU documentation Google Style Guide Python Official documentation PEP 8 Style Guide Python Institute certifications Golang Official documentation Google style guide NodeJS Official documentation Google style guide Java Dojo Java Troubleshooting Terraform Official documentation Hashicorp style guide Hashicorp certifications Terraform registry Terraform tutorials Ansible Official documentation Official style guide Red Hat Ansible certification Ansible Galaxy Advanced Skills DevOps Tools and processes for collaborative development and operations. Release cycles pipelines Network fundamentals DevOps definition Kubernetes The core technology at the heart of the Zillona project. Official documentation Helm documentation Helm style guide CKA certification Cloud Architecture Understanding the principles of cloud computing, common services and core concepts. Amazon Web Services Google Compute Platform Microsoft Azure Open Stack UNIX wizardry The deep lore. Wizardry from the bearded ancients Jargon file Regular Expressions Official Vim documentation Vim advanced guide","title":"Skill Tree Progression"},{"location":"skill_tree/#skill-tree-progression","text":"Follow the DevOps roadmap at roadmap.sh/devops to get a high-level idea of our skills roadmap. For details of our internal path see the skill tree below.","title":"Skill Tree Progression"},{"location":"skill_tree/#notes-for-contributors-to-this-document","text":"Link useful resources for each skill below Regularly vet 3rd party tutorials and prefer official tutorials where prudent Create exercises linking to existing documentation for complex tasks Try to order links as follows Official upstream project documentation Style guide if applicable Certification link if applicable Official registry or repository if applicable Official tutorials and examples 3rd party tutorials and examples Internal exercises and presentations","title":"Notes for Contributors to this document"},{"location":"skill_tree/#prerequisite-skills","text":"Things to know before you get involved. Navigate Linux filesystem Ubuntu tutorial Dojo Linux exercise #1 Edit local files Ubuntu tutorial Dojo Vim exercise #1 Basic Git usage Official beginers guide GitHub command examples Dojo git exercise #1","title":"Prerequisite Skills"},{"location":"skill_tree/#initial-skills","text":"Set up your development environment and gain confidence with the tools and skills outlined in this section to get started and become involved with Zillona Dojo projects. Install a Debian VM on your development workstation. Install cli tools and dependency packages (vim, git, curl, etc) Bash scripting (Save install steps) Create branch from \"develop\" branch of this repo and edit documentation Markdown Add, commit, and push changes to your new branch Validate changes to repository and create merge request to develop branch Install nginx in the VM Configure nginx from the CLI Install Docker on the VM Pull nginx Docker container for local validation","title":"Initial skills"},{"location":"skill_tree/#core-skills","text":"These are the most important and fundamental skills to develop as a newly initiated member of the Dojo. Linux Building on basic Linux skills Debian GNU/Linux documentation Git Building on basic git skills Official documentation Gitlab best practices guide Atlassian tutorials & guides Interactive branching tutorial Commit message guide Dojo git exercise #2 Docker Develop core Docker skills Official Documentation Dockerfile best practices Docker Hub Dojo Docker exercise #1","title":"Core Skills"},{"location":"skill_tree/#intermediate-skills","text":"Here the skill tree begins to branch out and become more dense and specialized. Refer to the DevOps roadmap to get your bearings. Amazon Web Services (AWS) Official documentation AWS certification Google Cloud Platform (GCP) Official documentation Google Cloud certificates Official tutorials Microsoft Azure Cloud Official documentation Azure certification Bash (Bourne Again SHell) Official GNU documentation Google Style Guide Python Official documentation PEP 8 Style Guide Python Institute certifications Golang Official documentation Google style guide NodeJS Official documentation Google style guide Java Dojo Java Troubleshooting Terraform Official documentation Hashicorp style guide Hashicorp certifications Terraform registry Terraform tutorials Ansible Official documentation Official style guide Red Hat Ansible certification Ansible Galaxy","title":"Intermediate Skills"},{"location":"skill_tree/#advanced-skills","text":"DevOps Tools and processes for collaborative development and operations. Release cycles pipelines Network fundamentals DevOps definition Kubernetes The core technology at the heart of the Zillona project. Official documentation Helm documentation Helm style guide CKA certification Cloud Architecture Understanding the principles of cloud computing, common services and core concepts. Amazon Web Services Google Compute Platform Microsoft Azure Open Stack UNIX wizardry The deep lore. Wizardry from the bearded ancients Jargon file Regular Expressions Official Vim documentation Vim advanced guide","title":"Advanced Skills"},{"location":"tabletech/","text":"TableTech Hosting of Foundry Virtual Table Top and development of related technologies. Slack: zillona.slack.com/channels/nerdsplaydnd Jira: zillona.atlassian.net/jira/core/projects/NPD/board Git repo: gitlab.com/nerdsplaydnd Website: nerdsplaydnd.com","title":"TableTech"},{"location":"tabletech/#tabletech","text":"Hosting of Foundry Virtual Table Top and development of related technologies. Slack: zillona.slack.com/channels/nerdsplaydnd Jira: zillona.atlassian.net/jira/core/projects/NPD/board Git repo: gitlab.com/nerdsplaydnd Website: nerdsplaydnd.com","title":"TableTech"},{"location":"vim_exercise-1/","text":"Vim Exercise Get hands on with VIM This exercise will guide you through basic VIM commands for editing text files. Task Create a File: Open a terminal and navigate to your desired directory. Create a new file named practice.txt using VIM: vi practice.txt Enter Insert Mode: Press the i key to enter insert mode. Notice the -- INSERT -- indicator at the bottom of the screen. Type a few sentences or lines of text. Exit Insert Mode: Press the Esc key to exit insert mode. Navigation: Use the arrow keys to move the cursor around the text. Try these commands for faster navigation: * h (left), j (down), k (up), l (right) * w (next word), b (previous word) * 0 (beginning of line), $ (end of line) Editing: Deleting: x deletes the character under the cursor. dw deletes a word. dd deletes an entire line. Copying/Pasting: yy copies (yanks) a line. p pastes the copied content below the current line. Undo/Redo: u undoes the last action. Ctrl-r redoes the last undone action. Saving and Exiting: Saving: Type :w and press Enter to save the changes. Exiting: Type :q and press Enter to quit VIM if you've saved changes. Type :q! and press Enter to quit without saving changes. Skills Practiced This exercise introduces you to: Opening and creating files with VIM Entering and exiting insert mode Basic navigation commands Essential editing commands (deleting, copying, pasting, undo/redo) Saving and exiting VIM By practicing these commands, you'll start building a foundation for efficient text editing in VIM. Official Resources Documentation: Vim User Manual: This is the comprehensive reference for all Vim features. Unfortunately, there's no single, direct link to it, as it's integrated into the Vim editor itself. To access it, open Vim and type :help followed by the specific topic you want to explore (e.g., :help insert ). Third-Party Resources Tutorials and Examples: Vim Tutorial: While not officially endorsed, this tutorial provides a good starting point: https://www.freecodecamp.org/news/vim-beginners-guide/ Learn Vimscript the Hard Way: This book offers a deep dive into Vim scripting: https://github.com/yuchao86/Learn-Vimscript-the-Hard-Way Open Vim: A web-based interactive Vim tutorial: https://opensource.com/article/19/3/getting-started-vim Note: Due to the nature of Vim, there might not be specific style guides or certifications associated with it. The community primarily relies on the extensive documentation and user-created resources.","title":"Vim Exercise"},{"location":"vim_exercise-1/#vim-exercise","text":"","title":"Vim Exercise"},{"location":"vim_exercise-1/#get-hands-on-with-vim","text":"This exercise will guide you through basic VIM commands for editing text files.","title":"Get hands on with VIM"},{"location":"vim_exercise-1/#task","text":"Create a File: Open a terminal and navigate to your desired directory. Create a new file named practice.txt using VIM: vi practice.txt Enter Insert Mode: Press the i key to enter insert mode. Notice the -- INSERT -- indicator at the bottom of the screen. Type a few sentences or lines of text. Exit Insert Mode: Press the Esc key to exit insert mode. Navigation: Use the arrow keys to move the cursor around the text. Try these commands for faster navigation: * h (left), j (down), k (up), l (right) * w (next word), b (previous word) * 0 (beginning of line), $ (end of line) Editing: Deleting: x deletes the character under the cursor. dw deletes a word. dd deletes an entire line. Copying/Pasting: yy copies (yanks) a line. p pastes the copied content below the current line. Undo/Redo: u undoes the last action. Ctrl-r redoes the last undone action. Saving and Exiting: Saving: Type :w and press Enter to save the changes. Exiting: Type :q and press Enter to quit VIM if you've saved changes. Type :q! and press Enter to quit without saving changes.","title":"Task"},{"location":"vim_exercise-1/#skills-practiced","text":"This exercise introduces you to: Opening and creating files with VIM Entering and exiting insert mode Basic navigation commands Essential editing commands (deleting, copying, pasting, undo/redo) Saving and exiting VIM By practicing these commands, you'll start building a foundation for efficient text editing in VIM.","title":"Skills Practiced"},{"location":"vim_exercise-1/#official-resources","text":"Documentation: Vim User Manual: This is the comprehensive reference for all Vim features. Unfortunately, there's no single, direct link to it, as it's integrated into the Vim editor itself. To access it, open Vim and type :help followed by the specific topic you want to explore (e.g., :help insert ).","title":"Official Resources"},{"location":"vim_exercise-1/#third-party-resources","text":"Tutorials and Examples: Vim Tutorial: While not officially endorsed, this tutorial provides a good starting point: https://www.freecodecamp.org/news/vim-beginners-guide/ Learn Vimscript the Hard Way: This book offers a deep dive into Vim scripting: https://github.com/yuchao86/Learn-Vimscript-the-Hard-Way Open Vim: A web-based interactive Vim tutorial: https://opensource.com/article/19/3/getting-started-vim Note: Due to the nature of Vim, there might not be specific style guides or certifications associated with it. The community primarily relies on the extensive documentation and user-created resources.","title":"Third-Party Resources"}]}